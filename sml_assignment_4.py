# -*- coding: utf-8 -*-
"""SML_ASSIGNMENT_4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QUvxXwLOH9yzO_0MOMBgciMUZJ9HyYcY
"""

import numpy as np
import mnist_reader
from scipy.special import logsumexp

!unzip mnist.zip

class neural_network:
  
  def __init__(self,network_struct,learning_rate,epoch):
      self.network_struct=network_struct
      self.learning_rate=learning_rate
      self.weight_matrix_array=list()
      self.bias_weight_matrix_array=list()
      self.epoch=epoch
      self.generate_weight_matrix()
    
  def sigma(self,x):
    scale = lambda y:1/(1+np.exp(-y))
    return scale(x)
  
  def activation_function(self,choice,x):
    if choice==1:
        return x
    elif choice==2:
        return np.multiply(x,(x > 0))
    elif choice==3:
        return self.sigma(x)
  
  def softmax(self,x):
      #x = np.log(np.max(x, 1e-9))
      e_x = np.exp(x - np.max(x))
      return e_x / e_x.sum()
    
  def derivative(self,choice,x,i):
    if choice==1:
        return 1
    elif choice==2:
        return np.multiply((x[len(x)-1-i] > 0),1)
    elif choice==3:
        return np.multiply(x[len(x)-1-i],(1.0-x[len(x)-1-i]))
     
  
  def generate_weight_matrix(self):
      for i in range(0,len(self.network_struct)-1):
          val=rad = 1 / np.sqrt(self.network_struct[i])
          p=np.random.uniform(-val,val,(self.network_struct[i+1],self.network_struct[i]))
          #self.weight_matrix_array.append(np.matrix(np.random.uniform(-val,val,(self.network_struct[i+1],self.network_struct[i]))))
          #self.bias_weight_matrix_array.append(np.matrix(np.random.uniform(-val,val,(self.network_struct[i+1],1))))
          self.weight_matrix_array.append(np.matrix(np.random.randn(self.network_struct[i+1],self.network_struct[i])))
          self.bias_weight_matrix_array.append(np.matrix(np.random.randn(self.network_struct[i+1],1)))
      self.weight_matrix_array=np.asarray(self.weight_matrix_array)
      self.bias_weight_matrix_array=np.asarray(self.bias_weight_matrix_array)
      
  def forward_propagate(self,inp,choice):
        inp=np.matrix(inp).transpose()
        output_node_matrix=list()
        output_node_matrix.append(inp)
        for i in range(0,len(self.network_struct)-1):
                weight_mul=np.matrix(np.dot(self.weight_matrix_array[i],inp))
                #weight_mul=np.add(weight_mul,np.matrix(self.bias_weight_matrix_array[i]))
                inp=[]
                if i!=len(self.network_struct)-2:
                   inp=np.array(self.activation_function(choice,weight_mul))
                   #inp=weight_mul
                else:
                  inp=np.array(self.softmax(weight_mul))
                output_node_matrix.append(inp)
        return output_node_matrix
      
  def backpropagate(self,y,output_node_matrix,choice):
        out_error=np.matrix(y).transpose()-output_node_matrix[len(output_node_matrix)-1] 
        delta_matrix=[]
        for i in range(0,len(self.network_struct)-1):
            if i==0:
                delta=out_error
                delta_matrix.append(delta)
            else:
                prev_delta=np.dot(np.matrix(self.weight_matrix_array[len(output_node_matrix)-1-i]).transpose(),delta_matrix[i-1])
                delta=np.multiply(self.derivative(choice,output_node_matrix,i),prev_delta)
                #delta=np.multiply(np.multiply(output_node_matrix[len(output_node_matrix)-1-i],
                 #                             (1.0-output_node_matrix[len(output_node_matrix)-1-i])),prev_delta)
                delta_matrix.append(delta)
            out_tr=np.matrix(output_node_matrix[len(output_node_matrix)-1-i-1])
            if i==0:
                update_weight = self.learning_rate  * np.dot(np.matrix(delta),np.matrix(out_tr).transpose())
            else:
                update_weight = self.learning_rate  * np.dot(np.matrix(delta),out_tr.transpose())
            self.weight_matrix_array[len(output_node_matrix)-1-i-1]+=update_weight
            if i==0:
              self.bias_weight_matrix_array[len(output_node_matrix)-1-i-1]+=self.learning_rate  * delta
            else:
              self.bias_weight_matrix_array[len(output_node_matrix)-1-i-1]+=self.learning_rate  * prev_delta
              
  def fit_data(self,x,y,choice):
      for i in range(0,self.epoch):
          c=0
          for i in range(0,len(x)):
              output_node_matrix=self.forward_propagate(x[i]/255,choice)
              if i==700:
                print(output_node_matrix)
              self.backpropagate(y[i],output_node_matrix,choice)
              c+=1                                       
              if c%10000==0:
                  print(c)
      
        
  def predict(self,test,choice):
    label=[]
    for t in test:
        output_node_matrix=self.forward_propagate(t/255,choice)
        #print(np.argmax(np.array(output_node_matrix[len(output_node_matrix)-1])))
        label.append(np.argmax(np.array(output_node_matrix[len(output_node_matrix)-1])))
    return label

X_train, y_train = mnist_reader.load_mnist('mnist', kind='train')
X_test, y_test = mnist_reader.load_mnist('mnist', kind='t10k')

train_label=[]
for t in y_train:
  temp=np.zeros(10)
  temp[t-1]=1
  train_label.append(temp)

type(X_train)

np.shape(X_train)

if __name__ == "__main__":
  classifier=neural_network([len(X_train[0]),32,10],0.1,1)
  #print(classifier.weight_matrix_array)
  #classifier.fit([[0,1]],[1,0])
  #classifier.predict([[0,1]])

mean = np.mean(X_train, axis=0)
std = np.std(X_train, axis=0)+0.000001

X_train = (X_train - mean) / std
X_test = (X_test - mean) /std

classifier.fit_data(X_train,train_label,2)
#classifier.fit_data(np.array([[0,1]]),np.array([[1,0]]),2)

print(classifier.weight_matrix_array)

print(y_test[:100])
label=classifier.predict(X_test,1)
print(label)
match=0
for i in range(0,len(y_test)):
  if label[i]==y_train[i]:
    match+=1
print(match/len(label)*100)

a=np.array([[1,1,1],[2,2,2]])
print(a)
print(a.transpose())

arr = np.array([[1, 2],[3,4]])
print(arr)
scale = lambda x: x **2
scale(arr)

x = np.array([1, 2,-3,4])
s=np.multiply(x, (x > 0))
print(s)
d=(x > 0) * 1
print(d)